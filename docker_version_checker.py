#!/usr/bin/env python3
"""
Docker Version Checker
----------------------
This script checks for the latest versions of Docker containers in a docker-compose file
and compares them with available versions on Docker Hub, Quay.io, and GitHub Container Registry.

Usage: python docker_version_checker.py [--compose FILE]
"""

import os
import sys
import yaml
import json
import re
import argparse
import requests
from datetime import datetime
from packaging import version
from concurrent.futures import ThreadPoolExecutor, as_completed

# Default containers to check if no docker-compose file is specified
DEFAULT_CONTAINERS = [
    "qdrant/qdrant",
    "ollama/ollama",
    "prom/prometheus",
    "n8nio/n8n",
    "flowiseai/flowise"
]

# HTML template for the report
HTML_TEMPLATE = r"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Version Report</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }}
        h1, h2 {{
            color: #2c3e50;
        }}
        .container {{
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        tr:hover {{
            background-color: #f5f5f5;
        }}
        .status {{
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 3px;
            display: inline-block;
        }}
        .up-to-date {{
            background-color: #d4edda;
            color: #155724;
        }}
        .update-available {{
            background-color: #fff3cd;
            color: #856404;
        }}
        .unknown {{
            background-color: #d1ecf1;
            color: #0c5460;
        }}
        .error {{
            background-color: #f8d7da;
            color: #721c24;
        }}
        .newer {{
            background-color: #e2e3e5;
            color: #383d41;
        }}
        .metadata {{
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 10px;
        }}
        .summary {{
            font-size: 1.1em;
            margin: 15px 0;
        }}
    </style>
</head>
<body>
    <h1>Docker Version Report</h1>
    <div class="container">
        <h2>Overview</h2>
        <p>Scan date: {scan_date}</p>
        <p>Docker Compose file: {compose_file}</p>
        <p class="summary">Containers scanned: {total_containers}</p>
        <p class="summary">Updates available: {updates_count}</p>
    </div>
    
    <div class="container">
        <h2>Version Comparison Results</h2>
        <table>
            <thead>
                <tr>
                    <th>Container</th>
                    <th>Docker Compose Version</th>
                    <th>Latest Available Version</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                {table_rows}
            </tbody>
        </table>
    </div>
    
    <div class="metadata">
        <p>Generated by Docker Version Checker on {generated_time}</p>
    </div>
</body>
</html>
"""

class DockerVersionChecker:
    def __init__(self, compose_file=None, output_file="docker_versions.json", html_report="docker_versions.html", threads=5):
        self.compose_file = compose_file
        self.output_file = output_file
        self.html_report = html_report
        self.max_threads = threads
        self.containers_to_check = DEFAULT_CONTAINERS if not compose_file else []
        self.latest_versions = {}
        self.compose_versions = {}
        self.comparison_results = []
    
    def run(self):
        """Main execution method"""
        print("Docker Version Checker")
        print("---------------------")
        
        # Extract container info from docker-compose if available
        if self.compose_file:
            if not os.path.exists(self.compose_file):
                print(f"Error: Docker compose file '{self.compose_file}' not found.")
                return 1
            
            print(f"\nExtracting containers from {self.compose_file}...")
            self.compose_versions = self.extract_container_versions()
            
            # Use containers from docker-compose file
            self.containers_to_check = list(self.compose_versions.keys())
            print(f"Found {len(self.containers_to_check)} containers in compose file.")
        
        # Check latest versions in parallel
        print(f"\nChecking latest versions for {len(self.containers_to_check)} containers...")
        self.check_latest_versions()
        
        # Compare versions
        if self.compose_file:
            print("\nComparing versions...")
            self.comparison_results = self.compare_versions()
            self.display_comparison_results()
        else:
            self.display_latest_versions()
        
        # Save results
        self.save_results()
        print(f"\nResults saved to {self.output_file}")
        
        # Generate HTML report
        self.generate_html_report()
        print(f"HTML report saved to {self.html_report}")
        
        return 0
    
    def extract_container_versions(self):
        """Extract container versions from docker-compose file"""
        container_versions = {}
        
        try:
            with open(self.compose_file, 'r') as f:
                compose_data = yaml.safe_load(f)
            
            services = compose_data.get('services', {})
            for service_name, service_config in services.items():
                if 'image' in service_config:
                    image = service_config['image']
                    
                    # Handle build context instead of image
                    if image is None and 'build' in service_config:
                        print(f"  Service {service_name} uses build directive, skipping.")
                        continue
                    
                    # Extract container and tag
                    if ':' in image:
                        container, tag = image.rsplit(':', 1)
                        container_versions[container] = tag
                    else:
                        container_versions[image] = 'latest'
            
            return container_versions
            
        except Exception as e:
            print(f"Error parsing docker-compose file: {e}")
            return {}
    
    def check_latest_versions(self):
        """Check latest versions for all containers in parallel"""
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            future_to_container = {
                executor.submit(self.get_latest_version, container): container 
                for container in self.containers_to_check
            }
            
            for future in as_completed(future_to_container):
                container = future_to_container[future]
                try:
                    version_info = future.result()
                    if version_info:
                        self.latest_versions[container] = version_info
                except Exception as e:
                    print(f"Error processing {container}: {e}")
    
    def get_latest_version(self, container):
        """Get latest version for a container from appropriate registry"""
        print(f"Checking {container}...")
        
        # Determine registry and handle accordingly
        if container.startswith("ghcr.io/"):
            # GitHub Container Registry
            repo_name = container.split('/', 1)[1]
            return self.get_ghcr_version(repo_name)
        elif container.startswith("quay.io/"):
            # Quay.io Registry
            repo_name = container.split('/', 1)[1]
            return self.get_quayio_version(repo_name)
        else:
            # Default to Docker Hub
            return self.get_dockerhub_version(container)
    
    def get_dockerhub_version(self, repo_name):
        """Get latest version from Docker Hub"""
        # Handle library/ prefix for official images
        if '/' not in repo_name:
            repo_name = f"library/{repo_name}"
            
        url = f"https://hub.docker.com/v2/repositories/{repo_name}/tags/?page_size=10"
        
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            # First look for semantic versions
            for tag in data.get('results', []):
                name = tag['name']
                if self.is_semantic_version(name):
                    return name
            
            # Then look for numeric versions
            for tag in data.get('results', []):
                name = tag['name']
                if name[0].isdigit() and '.' in name:
                    return name
                    
            # If nothing found, return 'latest'
            return 'latest'
            
        except Exception as e:
            print(f"  Error checking Docker Hub for {repo_name}: {e}")
            return None
    
    def get_quayio_version(self, repo_name):
        """Get latest version from Quay.io"""
        url = f"https://quay.io/api/v1/repository/{repo_name}/tag/"
        
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            # Get all tags and find semantic versions
            tags = [tag['name'] for tag in data.get('tags', []) 
                   if not tag.get('is_manifest_list', False)]
            
            return self.find_latest_semantic_version(tags) or 'latest'
            
        except Exception as e:
            print(f"  Error checking Quay.io for {repo_name}: {e}")
            return None
    
    def get_ghcr_version(self, repo_name):
        """Get latest version from GitHub Container Registry"""
        print(f"  Note: GHCR API may require authentication. Best effort only.")
        
        url = f"https://ghcr.io/v2/{repo_name}/tags/list"
        headers = {"Accept": "application/vnd.docker.distribution.manifest.v2+json"}
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 401:
                print(f"  Authentication required for {repo_name} on GHCR.")
                return None
                
            response.raise_for_status()
            data = response.json()
            
            tags = data.get('tags', [])
            return self.find_latest_semantic_version(tags) or 'latest'
            
        except Exception as e:
            print(f"  Error checking GHCR for {repo_name}: {e}")
            return None
    
    def is_semantic_version(self, tag):
        """Check if a tag is a semantic version"""
        return re.match(r'^v?(\d+)\.(\d+)\.(\d+)([-+].*)?$', tag) is not None
    
    def find_latest_semantic_version(self, tags):
        """Find the highest semantic version in a list of tags"""
        semantic_versions = {}
        
        for tag in tags:
            if self.is_semantic_version(tag):
                parsed = self.parse_version(tag)
                if parsed:
                    semantic_versions[parsed] = tag
        
        if semantic_versions:
            return semantic_versions[max(semantic_versions.keys())]
        
        # Check for numeric versions like 1.0, 2.3 etc.
        numeric_versions = {}
        for tag in tags:
            if re.match(r'^(\d+)\.(\d+)$', tag):
                try:
                    parsed = version.parse(tag)
                    numeric_versions[parsed] = tag
                except:
                    continue
        
        if numeric_versions:
            return numeric_versions[max(numeric_versions.keys())]
            
        return None
    
    def parse_version(self, tag):
        """Parse a version tag into a Version object"""
        match = re.match(r'^v?(\d+\.\d+\.\d+.*)', tag)
        if match:
            try:
                return version.parse(match.group(1))
            except version.InvalidVersion:
                return None
        return None
    
    def compare_versions(self):
        """Compare compose versions with latest versions"""
        results = []
        
        for container, compose_version in self.compose_versions.items():
            if container in self.latest_versions and self.latest_versions[container]:
                latest_version = self.latest_versions[container]
                
                # Special case for 'latest' tag
                if compose_version == 'latest':
                    results.append({
                        "container": container,
                        "compose_version": compose_version,
                        "latest_version": latest_version,
                        "status": "UNKNOWN (using latest tag)"
                    })
                    continue
                
                # Compare versions
                status = self.get_version_status(compose_version, latest_version)
                results.append({
                    "container": container,
                    "compose_version": compose_version,
                    "latest_version": latest_version,
                    "status": status
                })
            else:
                # Couldn't get latest version
                results.append({
                    "container": container,
                    "compose_version": compose_version,
                    "latest_version": "UNKNOWN",
                    "status": "COULDN'T DETERMINE"
                })
        
        return results
    
    def get_version_status(self, compose_version, latest_version):
        """Determine version status (up to date, update available)"""
        if compose_version == latest_version:
            return "UP TO DATE"
            
        # Handle v prefix differences
        if compose_version.lstrip('v') == latest_version.lstrip('v'):
            return "UP TO DATE (version format difference)"
        
        # Parse and compare versions
        v_compose = self.parse_version_str(compose_version)
        v_latest = self.parse_version_str(latest_version)
        
        if v_compose and v_latest:
            if v_compose < v_latest:
                return "UPDATE AVAILABLE"
            elif v_compose > v_latest:
                return "NEWER THAN LATEST (unusual)"
            else:
                return "UP TO DATE"
        
        # Can't compare as versions
        return "UNKNOWN (can't compare versions)"
    
    def parse_version_str(self, version_str):
        """Parse version string into comparable version object"""
        # Remove 'v' prefix if present for comparison
        if version_str and version_str.startswith('v'):
            version_str = version_str[1:]
        
        try:
            return version.parse(version_str)
        except:
            return None
    
    def display_comparison_results(self):
        """Display version comparison results"""
        print("\n--- Version Comparison Results ---")
        
        for result in self.comparison_results:
            print(f"{result['container']}:")
            print(f"  Compose version: {result['compose_version']}")
            print(f"  Latest version: {result['latest_version']}")
            print(f"  Status: {result['status']}")
            print()
    
    def display_latest_versions(self):
        """Display latest version information"""
        print("\n--- Latest Container Versions ---")
        for container, latest_version in self.latest_versions.items():
            if latest_version:
                print(f"{container}: {latest_version}")
            else:
                print(f"{container}: UNKNOWN")
        print()
    
    def save_results(self):
        """Save results to JSON file"""
        output_data = {
            "scan_date": datetime.now().isoformat(),
            "docker_compose_file": self.compose_file,
            "container_versions": self.latest_versions,
            "compose_versions": self.compose_versions,
            "comparison_results": self.comparison_results
        }
        
        try:
            with open(self.output_file, "w") as f:
                json.dump(output_data, f, indent=2)
        except Exception as e:
            print(f"Error saving results: {e}")
    
    def get_status_class(self, status):
        """Get CSS class for status display in HTML"""
        status_lower = status.lower()
        if "up to date" in status_lower:
            return "up-to-date"
        elif "update available" in status_lower:
            return "update-available"
        elif "unknown" in status_lower:
            return "unknown"
        elif "couldn't determine" in status_lower or "error" in status_lower:
            return "error"
        elif "newer" in status_lower:
            return "newer"
        return ""
    
    def generate_html_report(self):
        """Generate HTML report from results"""
        # Count updates available
        updates_count = sum(1 for result in self.comparison_results 
                           if "UPDATE AVAILABLE" in result["status"])
        
        # Generate table rows
        table_rows = ""
        for result in self.comparison_results:
            status_class = self.get_status_class(result["status"])
            table_rows += f"""
                <tr>
                    <td>{result["container"]}</td>
                    <td>{result["compose_version"]}</td>
                    <td>{result["latest_version"]}</td>
                    <td><span class="status {status_class}">{result["status"]}</span></td>
                </tr>
            """
        
        # Format HTML
        html_content = HTML_TEMPLATE.format(
            scan_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            compose_file=self.compose_file or "N/A",
            total_containers=len(self.comparison_results),
            updates_count=updates_count,
            table_rows=table_rows,
            generated_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        try:
            with open(self.html_report, "w") as f:
                f.write(html_content)
        except Exception as e:
            print(f"Error generating HTML report: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Docker Version Checker")
    parser.add_argument("--compose", dest="compose_file", default="docker-compose-ilan-stack.yaml",
                        help="Path to docker-compose.yaml file")
    parser.add_argument("--output", dest="output_file", default="docker_versions.json",
                        help="Output JSON file path")
    parser.add_argument("--html", dest="html_report", default="docker_versions.html",
                        help="Output HTML report path")
    parser.add_argument("--threads", dest="threads", type=int, default=5,
                        help="Number of concurrent threads to use")
    
    args = parser.parse_args()
    
    checker = DockerVersionChecker(
        compose_file=args.compose_file,
        output_file=args.output_file,
        html_report=args.html_report,
        threads=args.threads
    )
    
    return checker.run()

if __name__ == "__main__":
    sys.exit(main()) 